extend type Query {
    payments(name: String @like, voided: Boolean @eq, pending: Boolean @scope): 
        [Payment] @orderBy(column: "created_at", direction: DESC) @paginate
    payment(id: ID! @eq): Payment @find
}

extend type Mutation {
    createPayment(input: PaymentCreateInput! @spread): Payment @field(resolver: "PaymentMutation@store")
    voidPayment(input: VoidPaymentCreateInput! @spread): Payment @field(resolver: "PaymentMutation@void")
    updatePayment(input: PaymentUpdateInput! @spread): Payment @field(resolver: "PaymentMutation@update")
    deletePayment(id: ID! @eq): Payment @guard(with: ["api"]) @delete
}

input VoidPaymentCreateInput {
    id: ID! @rules(apply: ["required", "exists:payments,id"])
    voided_reason: String!
}

input PaymentCreateInput {
    bank_account_id: ID! @rules(apply: ["required", "exists:bank_accounts,id"])
    to_bank_account_id: ID
    transaction_amount: Float! @rules(apply: ["required"])
    transaction_date: Date!
    amount_in_words: String!
    payment_method: String!
    to: String!
    project: String!
    reason: String
}

input PaymentUpdateInput {
    id: ID! @rules(apply: ["required", "exists:payments,id"])
    bank_account_id: ID! @rules(apply: ["required", "exists:bank_accounts,id"])
    to_bank_account_id: ID
    transaction_amount: Float! @rules(apply: ["required"])
    amount_in_words: String!
    payment_method: String!
    transaction_date: Date!
    to: String!
    project: String!
    reason: String
}

type Payment {
    id: ID
    bank_account_id: ID
    transaction_amount: Float
    amount_in_words: String
    transaction_date: Date
    to: String
    project: String
    currency: String
    reason: String
    payment_method: String
    bankAccount: BankAccount
    voided: Boolean
    voided_date: String
    voided_reason: String
    payment_date: String
    payment_pending: Boolean
}
